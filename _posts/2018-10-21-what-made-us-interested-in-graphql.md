---
---
When I try to trace back why I think `GraphQL` is a good fit for us, I always end up somewhere in the years 2012, 2014 and 2016.

# 2012
In 2012 I started working for `XING` in the API - team. Together we launched `XING`s public API that same year. The infrastructure for that had already been in place for roughly two years (I think) and was also the data source for `XING`s own native mobile applications. In fact many of the APIs that you would find later in the public API originated in the context of those applications and at least for a short time there was a 100% overlap between the public API and what the mobile apps were using. 

One thing we already had at that time was a query parameter called `fields` on the users API and `user_fields` on every API that was referencing users. These query parameters expected a comma separated list of field names and if you would call the API that way, you'd only get back what you had requested. It even supported nesting so you could request `business_address.city` to only get the city portion of the business address. If you look at it now from a `GraphQL` perspective, you might think "wait a minute, that sounds almost like a selection set" and I think this isn't too far off. It had the same benefits (tracking, e.g. who is using what and bandwidth optimization, e.g. only transfer what the client actually needs) but obviously ours was a very simple, poor mans version of the idea.

Unfortunately, driven by the overarching goal to make things as straightforward to use as possible, the team looked at this only as an optimization. If you didn't specify the fields, you would get everything. I bet you can already guess what happened: While our mobile applications made good use of this, most of the other consumers of the public API didn't, which gave us quite some headakes when we wanted to change something. 

Talking about change, I think there's a field of tension if you're attempting to re-use a public API for your mobile applications (or the other way around) like we did. Good public APIs are like a promise of stability. They change very infrequently. You can rely on them and build solid integrations on them. And judging from my experience, it takes significant time to design them that way. On the other end of the spectrum are your own mobile applications where you (or at least the company) more often than not want to iterate fast, get features out as fast as you can and learn based on actual usage. These two things were always at odds at the time. Often the desired change some of our product teams wanted to make wasn't easily possible without breaking exising consumers of the public API, or introducing some kind of versioning which tried not to do at the time (since we just had come out with the v1 of the API). Usually it would result in either additional API calls to get the necessary data or adding data to existing APIs and consumers whould receive additional data they don't actually need. 

This is usually the place where somebody from the side steps in, screaming: "Stop, stop, stop! You're doing it wrong. That's actually not REST you're talking about". Oh, I did forget to tell you that, didn't it? Like most people at the time we were labeling our API a REST API. Yikes! In reality ours was closer to RESTful APIs or simply `JSON` over `HTTP`. Like a lot of people at the time I was heavily reading about `REST` and `Hypermedia` including, but not limited to, Fieldings thesis. For a brief time I was convinced that at least from the backend perspective it would solve some of the coupling problems we faced with our API consumers and would give us [more flexibility for the API](http://bjro.de/2012/10/16/the-pain-of-a-non-hypermedia-http-api/).

Whenver I tried to convince my peers though, discussions usually ended with them having a blank stare, once they realized what clients had to do in order to make the `Hypermedia` game a reality. This was especially true for our mobile developers. I still remember the sentence "So, you kinda want me to turn our app into a browser?".  TODO: Complete

 And they were (and still are) good, knowledgable folks. I think part of it boils down to the fact that there wasn't (and to my knowledge still isn't) a widely adopted standard (excluding HTML and browsers). As a consequence, client tooling was not really available and everything would needed to be created from scratch. Later things like `hal`, `collection+json` and other formats appeared, but the story was never end to end, if you zoom out a bit. 

TODO: Rephrase I never forget the realization when one of my mobile colleagues asked me while processing all of this "So you want me to build a browser?"

# 2014

# 2016